#  [BOJ] 1697번 : 숨바꼭질

## BOJ: https://www.acmicpc.net/problem/1697

## 1. 문제

|시간 제한| 메모리 제한| 
|:----|:----|
|2초|128MB|

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

#### 입력
첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

#### 출력
수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

#### 예제 입력 1
```
5 17
```
#### 예제 출력 1
```
4
```
## 2. 풀이
- 현재 위치 N에서 이동할 수 있는 경우는 총 세 가지이다. (X-1, X+1, 2X)
- 현재 위치를 이동 시키고 위치 K와 같은 지 비교하여 찾는다. (너비 우선 탐색)
- 위치를 이동 시켰을 때 K가 아니라면 큐에 삽입한다. 이 때 이동시킨 위치가 이미 방문된 위치라면 삽입하지 않는다.
- 이동한 위치가 K라면 종료한다.

## 3. 작성 답안
```python
import sys
import copy
from collections import deque 

N, K = map(int, sys.stdin.readline().split())

q = deque()
q.append([N, 0])
v = [0 for i in range(100001)]
v[N] = 1

while len(q) != 0:
	cur = q.popleft()
	if cur[0] == K:
		print(cur[1])
		break
	if 0 <= cur[0] + 1 <= 100000:
		if v[cur[0] + 1] == 0:
			q.append([cur[0] + 1, cur[1] + 1])
			v[cur[0] + 1] = 1
	if 0 <= cur[0] - 1 <= 100000:
		if v[cur[0] - 1] == 0:
			q.append([cur[0] - 1, cur[1] + 1])
			v[cur[0] - 1] = 1
	if 0 <= cur[0] * 2 <= 100000:
		if v[cur[0] * 2] == 0:
			q.append([cur[0] * 2, cur[1] + 1])
			v[cur[0] * 2] = 1
```
## 4. 기타
- 이미 방문된 위치를 다시 방문 하는 것을 주의. (방문 처리에 주의)
